(base) danielme@valentine:/host/verges/tank/data$ wb_command -metric-smoothing
SMOOTH A METRIC FILE
   wb_command -metric-smoothing
      <surface> - the surface to smooth on
      <metric-in> - the metric to smooth
      <smoothing-kernel> - the size of the gaussian smoothing kernel in mm, as
         sigma by default
      <metric-out> - output - the output metric

      [-fwhm] - kernel size is FWHM, not sigma

      [-roi] - select a region of interest to smooth
         <roi-metric> - the roi to smooth within, as a metric

         [-match-columns] - for each input column, use the corresponding column
            from the roi

      [-fix-zeros] - treat zero values as not being data

      [-column] - select a single column to smooth
         <column> - the column number or name

      [-corrected-areas] - vertex areas to use instead of computing them from
         the surface
         <area-metric> - the corrected vertex areas, as a metric

      [-method] - select smoothing method, default GEO_GAUSS_AREA
         <method> - the name of the smoothing method

      Smooth a metric file on a surface.  By default, smooths all input columns
      on the entire surface, specify -column to use only one input column, and
      -roi to smooth only where the roi metric is greater than 0, outputting
      zeros elsewhere.

      When using -roi, input data outside the ROI is not used to compute the
      smoothed values.  By default, the first column of the roi metric is used
      for all input columns.  When -match-columns is specified to the -roi
      option, the input and roi metrics must have the same number of columns,
      and for each input column's index, the same column index is used in the
      roi metric.  If the -match-columns option to -roi is used while the
      -column option is also used, the number of columns must match between the
      roi and input metric, and it will use the roi column with the index of
      the selected input column.

      The -fix-zeros option causes the smoothing to not use an input value if
      it is zero, but still write a smoothed value to the vertex.  This is
      useful for zeros that indicate lack of information, preventing them from
      pulling down the intensity of nearby vertices, while giving the zero an
      extrapolated value.

      The -corrected-areas option is intended for when it is unavoidable to
      smooth on a group average surface, it is only an approximate correction
      for the reduction of structure in a group average surface.  It is better
      to smooth the data on individuals before averaging, when feasible.

      Valid values for <method> are:

      GEO_GAUSS_AREA - uses a geodesic gaussian kernel, and normalizes based on
      vertex area in order to work more reliably on irregular surfaces

      GEO_GAUSS_EQUAL - uses a geodesic gaussian kernel, and normalizes
      assuming each vertex has equal importance

      GEO_GAUSS - matches geodesic gaussian smoothing from caret5, but does not
      check kernels for having unequal importance

      The GEO_GAUSS_AREA method is the default because it is usually the
      correct choice.  GEO_GAUSS_EQUAL may be the correct choice when the sum
      of vertex values is more meaningful then the surface integral (sum of
      values .* areas), for instance when smoothing vertex areas (the sum is
      the total surface area, while the surface integral is the sum of squares
      of the vertex areas).  The GEO_GAUSS method is not recommended, it exists
      mainly to replicate methods of studies done with caret5's geodesic
      smoothing.


(base) danielme@valentine:/host/verges/tank/data/daniel$ wb_command -volume-to-surface-mapping
MAP VOLUME TO SURFACE
   wb_command -volume-to-surface-mapping
      <volume> - the volume to map data from
      <surface> - the surface to map the data onto
      <metric-out> - output - the output metric file

      [-trilinear] - use trilinear volume interpolation

      [-enclosing] - use value of the enclosing voxel

      [-cubic] - use cubic splines

      [-ribbon-constrained] - use ribbon constrained mapping algorithm
         <inner-surf> - the inner surface of the ribbon
         <outer-surf> - the outer surface of the ribbon

         [-volume-roi] - use a volume roi
            <roi-volume> - the roi volume file

            [-weighted] - treat the roi values as weightings rather than binary

         [-voxel-subdiv] - voxel divisions while estimating voxel weights
            <subdiv-num> - number of subdivisions, default 3

         [-thin-columns] - use non-overlapping polyhedra

         [-gaussian] - reduce weight to voxels that aren't near <surface>
            <scale> - value to multiply the local thickness by, to get the
               gaussian sigma

         [-interpolate] - instead of a weighted average of voxels, interpolate
            at subpoints inside the ribbon
            <method> - interpolation method, must be CUBIC, ENCLOSING_VOXEL, or
               TRILINEAR

         [-bad-vertices-out] - output an ROI of which vertices didn't intersect
            any valid voxels
            <roi-out> - output - the output metric file of vertices that have
               no data

         [-output-weights] - write the voxel weights for a vertex to a volume
            file
            <vertex> - the vertex number to get the voxel weights for, 0-based
            <weights-out> - output - volume to write the weights to

         [-output-weights-text] - write the voxel weights for all vertices to a
            text file
            <text-out> - output - the output text filename

      [-myelin-style] - use the method from myelin mapping
         <ribbon-roi> - an roi volume of the cortical ribbon for this
            hemisphere
         <thickness> - a metric file of cortical thickness
         <sigma> - gaussian kernel in mm for weighting voxels within range

         [-legacy-bug] - emulate old v1.2.3 and earlier code that didn't follow
            a cylinder cutoff

      [-subvol-select] - select a single subvolume to map
         <subvol> - the subvolume number or name

      You must specify exactly one mapping method.  Enclosing voxel uses the
      value from the voxel the vertex lies inside, while trilinear does a 3D
      linear interpolation based on the voxels immediately on each side of the
      vertex's position.

      The ribbon mapping method constructs a polyhedron from the vertex's
      neighbors on each surface, and estimates the amount of this polyhedron's
      volume that falls inside any nearby voxels, to use as the weights for
      sampling.  If -thin-columns is specified, the polyhedron uses the edge
      midpoints and triangle centroids, so that neighboring vertices do not
      have overlapping polyhedra.  This may require increasing -voxel-subdiv to
      get enough samples in each voxel to reliably land inside these smaller
      polyhedra.  The volume ROI is useful to exclude partial volume effects of
      voxels the surfaces pass through, and will cause the mapping to ignore
      voxels that don't have a positive value in the mask.  The subdivision
      number specifies how it approximates the amount of the volume the
      polyhedron intersects, by splitting each voxel into NxNxN pieces, and
      checking whether the center of each piece is inside the polyhedron.  If
      you have very large voxels, consider increasing this if you get zeros in
      your output.  The -gaussian option makes it act more like the myelin
      method, where the distance of a voxel from <surface> is used to
      downweight the voxel.  The -interpolate suboption, instead of doing a
      weighted average of voxels, interpolates from the volume at the
      subdivided points inside the ribbon.  If using both -interpolate and the
      -weighted suboption to -volume-roi, the roi volume weights are linearly
      interpolated, unless the -interpolate method is ENCLOSING_VOXEL, in which
      case ENCLOSING_VOXEL is also used for sampling the roi volume weights.

      The myelin style method uses part of the caret5 myelin mapping command to
      do the mapping: for each surface vertex, take all voxels that are in a
      cylinder with radius and height equal to cortical thickness, centered on
      the vertex and aligned with the surface normal, and that are also within
      the ribbon ROI, and apply a gaussian kernel with the specified sigma to
      them to get the weights to use.  The -legacy-bug flag reverts to the
      unintended behavior present from the initial implementation up to and
      including v1.2.3, which had only the tangential cutoff and a bounding box
      intended to be larger than where the cylinder cutoff should have been.

